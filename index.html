<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perudo Leaderboard</title>
    <link rel="icon" type="image/jpeg" href="./tucano.jpg">
    <link rel="apple-touch-icon" href="./tucano.jpg">
    <style>
        :root {
            --color-primary: #00aeef;/*#2b7a6f;**/
            --color-primary-hover: #1f5a52;
            --color-gold: #f39c12;
            --color-silver: #b0b0b0;
            --color-bronze: #ce8946;
            --color-last: #111111;
            --color-bg: #f5f5f5;
            --color-surface: #ffffff;
            --color-text: #333333;
            --color-text-light: #666666;
            --color-success: #27ae60;
            --color-error: #e74c3c;
            --color-border: #ddd;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --graph-colours: ['rgba(27, 158, 119, 1)',
            'rgba(217, 95, 2, 1)',
            'rgba(117, 112, 179, 1)',
            'rgba(231, 41, 137, 1)',
            'rgba(102, 166, 30, 1)'];
            --graph-dashes: [[],[10, 10], [1,1]]
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: var(--spacing-md);
            background: linear-gradient(-45deg, #f5f5f5, #e8f5e9, #e3f2fd, #f3e5f5);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: var(--color-text);
            min-height: 100vh;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
            padding-bottom: 80px;
        }
        
        .floating-dice {
            position: fixed;
            pointer-events: none;
            z-index: 0;
            opacity: 0.05;
            font-size: 80px;
            animation: floatAround 20s linear infinite;
        }
        
        .floating-dice:nth-child(1) {
            left: 10%;
            animation-duration: 15s;
            animation-delay: 0s;
        }
        
        .floating-dice:nth-child(2) {
            right: 10%;
            animation-duration: 20s;
            animation-delay: 5s;
        }
        
        .floating-dice:nth-child(3) {
            left: 50%;
            animation-duration: 25s;
            animation-delay: 10s;
        }
        
        @keyframes floatAround {
            0% {
                transform: translateY(100vh) rotate(0deg);
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
            }
        }

        header {
            background: linear-gradient(135deg, var(--color-primary) 0%, #1f5a52 100%);
            color: white;
            padding: var(--spacing-lg);
            border-radius: 8px;
            margin-bottom: var(--spacing-lg);
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        header::before {
            content: 'üé≤';
            position: absolute;
            font-size: 60px;
            opacity: 0.1;
            animation: floatDice 6s ease-in-out infinite;
            left: 10%;
            top: 50%;
        }
        
        header::after {
            content: 'üé≤';
            position: absolute;
            font-size: 40px;
            opacity: 0.1;
            animation: floatDice 8s ease-in-out infinite;
            right: 15%;
            top: 30%;
            animation-delay: 2s;
        }
        
        @keyframes floatDice {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(180deg); }
        }

        header h1 {
            margin: 0;
            font-size: 28px;
            position: relative;
            z-index: 1;
            animation: fadeInDown 0.8s ease;
        }
        
        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .nav-tabs {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: flex-end;
            background-color: white;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            padding: 2px 8px 2px 8px;
            padding-bottom: max(2px, env(safe-area-inset-bottom));
            height: 75px;
        }

        .nav-tabs button {
            flex: 1;
            padding: 8px 4px 4px 4px;
            border: none;
            background: none;
            color: var(--color-text-light);
            cursor: pointer;
            font-size: 24px;
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            transform: translateY(-16px);
        }
        
        .nav-tabs button[data-tab="home"] {
            flex: 1.2;
            font-size: 28px;
            padding: 10px 8px;
            margin: 0 4px;
            background: linear-gradient(135deg, var(--color-primary) 0%, #1f5a52 100%);
            color: white;
            box-shadow: 0 -4px 12px rgba(43, 122, 111, 0.4);
            border-radius: 20px 20px 16px 16px;
            transform: translateY(-16px);
        }
        
        .nav-tabs button[data-tab="home"].active {
            background: linear-gradient(135deg, var(--color-primary) 0%, #1f5a52 100%);
            color: white;
        }
        
        .nav-tabs button span {
            font-size: 10px;
            font-weight: 500;
        }
        
        .nav-tabs button[data-tab="home"] span {
            font-size: 10px;
            font-weight: 600;
        }

        .nav-tabs button.active {
            color: var(--color-primary);
            background-color: rgba(43, 122, 111, 0.1);
        }
        
        .nav-tabs button:active {
            transform: translateY(-16px) scale(0.95);
        }
        
        .nav-tabs button[data-tab="home"]:active {
            transform: translateY(-16px) scale(0.95);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .card {
            background-color: var(--color-surface);
            padding: var(--spacing-lg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: var(--spacing-md);
            animation: slideUp 0.5s ease;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .form-group {
            margin-bottom: var(--spacing-md);
        }

        label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
            color: var(--color-text);
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--color-border);
            border-radius: 6px;
            font-size: 16px;
            font-family: inherit;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 0 3px rgba(43, 122, 111, 0.1);
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
        }

        .form-row.full {
            grid-template-columns: 1fr;
        }

        .players-list {
            margin-bottom: var(--spacing-lg);
        }

        .player-item {
            display: flex;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-md);
            background-color: #f9f9f9;
            border-radius: 6px;
            align-items: center;
        }

        .player-item input {
            margin-bottom: 0;
        }

        .player-item button {
            background-color: var(--color-error);
            color: white;
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            flex-shrink: 0;
        }

        .player-item button:hover {
            background-color: #c0392b;
        }

        .player-input-wrapper {
            position: relative;
            flex: 1;
        }

        .player-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid var(--color-border);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .player-suggestions.show {
            display: block;
        }

        .suggestion-item {
            padding: 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .suggestion-item:hover {
            background-color: #f5f5f5;
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background-color: var(--color-primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--color-primary-hover);
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .btn-full {
            width: 100%;
        }

        .result-form {
            margin-bottom: var(--spacing-md);
        }

        .result-item {
            padding: var(--spacing-md);
            background-color: #f9f9f9;
            border-radius: 6px;
            margin-bottom: var(--spacing-md);
            border-left: 4px solid var(--color-primary);
        }

        .result-item h4 {
            margin: 0 0 var(--spacing-sm) 0;
            color: var(--color-primary);
        }

        .result-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: var(--spacing-lg);
        }

        .leaderboard-table thead {
            background-color: var(--color-primary);
            color: white;
        }

        .leaderboard-table th,
        .leaderboard-table td {
            padding: 12px;
            text-align: center;
            border-bottom: 1px solid var(--color-border);
        }

        .leaderboard-table tbody tr:hover {
            background-color: #f0f0f0;
        }

        .leaderboard-table .rank {
            font-weight: bold;
            color: var(--color-primary);
            min-width: 40px;
        }

        .leaderboard-table .points {
            font-weight: 600;
            color: var(--color-primary);
        }

        .leaderboard-table .positive {
            color: var(--color-primary);
        }

        .leaderboard-table .negative {
            color: var(--color-error);
        }


        .game-history {
            margin-top: var(--spacing-lg);
        }

        .game-card {
            background-color: #f9f9f9;
            padding: var(--spacing-md);
            border-radius: 6px;
            margin-bottom: var(--spacing-md);
            border-left: 4px solid var(--color-primary);
            position: relative;
        }
        
        .game-card .delete-game-btn {
            position: absolute;
            top: var(--spacing-md);
            right: var(--spacing-md);
            background-color: var(--color-error);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .game-card .delete-game-btn:hover {
            background-color: #c0392b;
            transform: scale(1.1);
        }

        .game-card h4 {
            margin: 0 0 var(--spacing-sm) 0;
            color: var(--color-primary);
        }

        .game-card p {
            margin: 4px 0;
            font-size: 14px;
            color: var(--color-text-light);
        }

        .game-card-result {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-top: var(--spacing-md);
        }

        .game-result-item {
            padding: 8px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid var(--color-border);
        }

        .game-result-item strong {
            color: var(--color-primary);
        }

        .empty-state {
            text-align: center;
            padding: var(--spacing-lg);
            color: var(--color-text-light);
        }

        .alert {
            padding: var(--spacing-md);
            border-radius: 6px;
            margin-bottom: var(--spacing-md);
        }

        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .alert-warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .sync-status {
            text-align: center;
            font-size: 12px;
            color: var(--color-text-light);
            margin-top: 8px;
        }

        .sync-status.synced {
            color: var(--color-success);
        }
        
        .player-name-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--spacing-sm);
            margin-top: var(--spacing-md);
        }
        
        .player-name-tag {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #f9f9f9;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid var(--color-border);
        }
        
        .player-name-tag.editing {
            background-color: #fff3cd;
            border-color: var(--color-primary);
        }
        
        .player-name-tag span {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .player-name-tag input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid var(--color-primary);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .player-name-tag .button-group {
            display: flex;
            gap: 4px;
            margin-left: 8px;
            flex-shrink: 0;
        }
        
        .player-name-tag button {
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .player-name-tag .btn-edit {
            background-color: #3498db;
        }
        
        .player-name-tag .btn-edit:hover {
            background-color: #2980b9;
        }
        
        .player-name-tag .btn-save {
            background-color: var(--color-success);
        }
        
        .player-name-tag .btn-save:hover {
            background-color: #229954;
        }
        
        .player-name-tag .btn-cancel {
            background-color: #95a5a6;
        }
        
        .player-name-tag .btn-cancel:hover {
            background-color: #7f8c8d;
        }
        
        .player-name-tag .btn-delete {
            background-color: var(--color-error);
        }
        
        .player-name-tag .btn-delete:hover {
            background-color: #c0392b;
        }
        
        .add-player-form {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-lg);
        }
        
        .add-player-form input {
            flex: 1;
        }
        
        .add-player-form button {
            flex-shrink: 0;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-lg);
        }
        
        .chart-container {
            background-color: white;
            padding: var(--spacing-lg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .chart-container h3 {
            margin: 0 0 var(--spacing-md) 0;
            color: var(--color-primary);
            font-size: 18px;
        }
        
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        
        .podium-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-lg);
        }
        
        .podium-card {
            background: white;
            padding: var(--spacing-md);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .podium-card h3 {
            margin: 0 0 var(--spacing-md) 0;
            font-size: 16px;
            color: var(--color-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .podium-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .podium-list li {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .podium-list li:last-child {
            border-bottom: none;
        }
        
        .podium-list .player-name {
            font-weight: 500;
        }

        .podium-list.count {
        background-color: var(--color-primary);
        color: white;
        width: 24px;

        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;

        font-size: 12px;
        font-weight: 600;
        border-radius: 12px;
        }


        @media (max-width: 600px) {
            .form-row {
                grid-template-columns: 1fr;
            }

            .result-form-row {
                grid-template-columns: 1fr;
            }

            .game-card-result {
                grid-template-columns: 1fr;
            }

            .leaderboard-table {
                font-size: 14px;
            }

            .leaderboard-table th,
            .leaderboard-table td {
                padding: 8px;
            }

            header h1 {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="floating-dice">üé≤</div>
    <div class="floating-dice">üé≤</div>
    <div class="floating-dice">üé≤</div>
    
    <div class="container">
        <header>
            <h1>üé≤ Perudo Leaderboard</h1>
            <div class="sync-status" id="syncStatus">Connessione...</div>
        </header>

        <div class="nav-tabs">
            <button class="tab-btn" data-tab="nuova-partita">
                ‚ûï
                <span>Nuova</span>
            </button>
            <button class="tab-btn" data-tab="giocatori">
                üë•
                <span>Giocatori</span>
            </button>
            <button class="tab-btn active" data-tab="home">
                üè†
                <span>Home</span>
            </button>
            <button class="tab-btn" data-tab="classifica">
                üèÜ
                <span>Classifica</span>
            </button>
            <button class="tab-btn" data-tab="storico">
                üìú
                <span>Storico</span>
            </button>
        </div>

        <!-- TAB: Home (Dashboard) -->
        <div id="home" class="tab-content active">
            <div class="card">
                <h2>Tavolo</h2>
                <div class="podium-grid">
                    <div class="podium-card">
                        <h3>üë• Tutti i Giocatori</h3>
                        <ul class="podium-list" id="allPlayersList"></ul>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: var(--spacing-md); margin-top: var(--spacing-lg);">
                    <button class="btn btn-primary btn-full" id="shufflePlayersBtn">Mischia Giocatori</button>
                    <button class="btn btn-primary btn-full" id="addPlayerBtn2">Aggiungi Giocatori</button>
                    <button class="btn btn-primary btn-full" id="updateTableBtn">Aggiorna Tavolo</button>
                </div>
                
                <div id="shuffledPlayersContainer" style="display: none; margin-top: var(--spacing-lg);">
                    <h3>Ordine Casuale</h3>
                    <ol class="podium-list" id="shuffledPlayersList"></ol>
                </div>

                <script>
                let selectedPlayers = new Set();
                let previousSelectedPlayers = new Set();
                let shuffledOrder = [];

                function updateAllPlayersList() {
                    const list = document.getElementById('allPlayersList');
                    if (!list) return;
                    
                    if (savedPlayerNames.length === 0) {
                        list.innerHTML = '<li style="color: #999;">Nessun giocatore nel database</li>';
                        return;
                    }
                    
                    list.innerHTML = savedPlayerNames.map(playerName => {
                        const gameCount = games.reduce((count, game) => {
                            return count + (game.results?.some(r => r.playerName === playerName) ? 1 : 0);
                        }, 0);
                        
                        const isSelected = selectedPlayers.has(playerName);
                        
                        return `<li style="display: flex; justify-content: space-between; align-items: center; padding: 12px; background-color: ${isSelected ? 'rgba(0, 174, 239, 0.1)' : '#f9f9f9'}; border-radius: 6px; margin-bottom: 8px; border: ${isSelected ? '2px solid var(--color-primary)' : '1px solid var(--color-border)'};">
                            <span class="player-name">${playerName}</span>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <!--<span style="color: white; font-weight: bold; border-radius: 50%; padding: 0; background-color: var(--color-primary); width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 12px;">${gameCount}</span>-->
                                <input type="checkbox" class="player-toggle" data-player="${playerName}" ${isSelected ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer;" />
                            </div>
                        </li>`;
                    }).join('');
                    
                    // Add event listeners to toggles
                    document.querySelectorAll('.player-toggle').forEach(toggle => {
                        toggle.addEventListener('change', function() {
                            const playerName = this.dataset.player;
                            if (this.checked) {
                                selectedPlayers.add(playerName);
                            } else {
                                selectedPlayers.delete(playerName);
                            }
                            updateAllPlayersList();
                        });
                    });
                }

                function shufflePlayers() {
                    const container = document.getElementById('shuffledPlayersContainer');
                    const list = document.getElementById('shuffledPlayersList');
                    
                    if (selectedPlayers.size === 0) {
                        alert('Seleziona almeno un giocatore');
                        return;
                    }
                    
                    // Convert to array and shuffle
                    shuffledOrder = Array.from(selectedPlayers);
                    for (let i = shuffledOrder.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffledOrder[i], shuffledOrder[j]] = [shuffledOrder[j], shuffledOrder[i]];
                    }
                    
                    previousSelectedPlayers = new Set(selectedPlayers);
                    displayShuffledList(list, container);
                }

                function displayShuffledList(list, container) {
                    list.innerHTML = shuffledOrder.map((playerName, index) => {
                        return `<li style="padding: 12px; background-color: #f9f9f9; border-radius: 6px; margin-bottom: 8px; border-left: 4px solid var(--color-primary);">
                            <span style="font-weight: 600; color: var(--color-primary); margin-right: 12px;">${index + 1}¬∞</span>
                            <span>${playerName}</span>
                        </li>`;
                    }).join('');
                    
                    container.style.display = 'block';
                }

                function addPlayerToShuffledList() {
                    const container = document.getElementById('shuffledPlayersContainer');
                    const list = document.getElementById('shuffledPlayersList');
                    
                    if (shuffledOrder.length === 0) {
                        alert('Esegui prima "Mischia Giocatori"');
                        return;
                    }
                    
                    // Find newly selected players
                    const newPlayers = Array.from(selectedPlayers).filter(p => !previousSelectedPlayers.has(p));
                    
                    if (newPlayers.length === 0) {
                        alert('Seleziona un nuovo giocatore da aggiungere');
                        return;
                    }
                    
                    // Add each new player at a random position
                    newPlayers.forEach(playerName => {
                        const randomIndex = Math.floor(Math.random() * (shuffledOrder.length + 1));
                        shuffledOrder.splice(randomIndex, 0, playerName);
                    });
                    
                    previousSelectedPlayers = new Set(selectedPlayers);
                    displayShuffledList(list, container);
                }

                function updateTable() {
                    const container = document.getElementById('shuffledPlayersContainer');
                    const list = document.getElementById('shuffledPlayersList');
                    
                    if (shuffledOrder.length === 0) {
                        alert('Esegui prima "Mischia Giocatori"');
                        return;
                    }
                    
                    // Remove players that are no longer selected
                    shuffledOrder = shuffledOrder.filter(playerName => selectedPlayers.has(playerName));
                    
                    if (shuffledOrder.length === 0) {
                        container.style.display = 'none';
                        alert('Nessun giocatore rimasto nella lista');
                        return;
                    }
                    
                    previousSelectedPlayers = new Set(selectedPlayers);
                    displayShuffledList(list, container);
                }

                // Setup button listeners
                document.addEventListener('DOMContentLoaded', function() {
                    const shuffleBtn = document.getElementById('shufflePlayersBtn');
                    if (shuffleBtn) {
                        shuffleBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            shufflePlayers();
                        });
                    }
                    
                    const addPlayerBtn = document.getElementById('addPlayerBtn2');
                    if (addPlayerBtn) {
                        addPlayerBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            addPlayerToShuffledList();
                        });
                    }

                    const updateTableBtn = document.getElementById('updateTableBtn');
                    if (updateTableBtn) {
                        updateTableBtn.addEventListener('click', function(e) {
                            e.preventDefault();
                            updateTable();
                        });
                    }
                });

                // Update when app initializes and data changes
                const originalLoadFromFirebase = loadFromFirebase;
                loadFromFirebase = function() {
                    originalLoadFromFirebase();
                    setTimeout(() => updateAllPlayersList(), 100);
                };

                const originalUpdateGameHistory = updateGameHistory;
                updateGameHistory = function() {
                    originalUpdateGameHistory();
                    updateAllPlayersList();
                };
                </script>
                </script>
            </div>
        </div>

        <!-- TAB: Nuova Partita -->
        <div id="nuova-partita" class="tab-content">
            <div class="card">
                <h2>Nuova Partita</h2>
                <div class="form-group">
                    <label>Data della partita</label>
                    <input type="date" id="gameDate" />
                    <div id="dateAlert" style="margin-top: 8px;"></div>
                </div>

                <h2>Giocatori</h2>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    Se un giocatore abbandona il gioco, √® come se perdesse tutti i dadi che rimangono uno dopo l'altro.<br>
                    <br>
                    Se due o pi√π giocatori abbandonano il gioco contemporaneamente, √® come se perdessero i dadi a turno, partendo da quello che ha meno dadi rimasti.<br>
                    Nel caso in cui due o pi√π giocatori abbiano lo stesso numero di dadi, parte quello che ha perso il dado per primo.<br>
                    Nel caso in cui non sia possibile determinare chi perde il primo dado, i giocatori lanciano un dado ciascuno e chi ottiene il numero pi√π basso perde il dado per primo.<br>
                </p>
                <div class="players-list" id="playersList"></div>
                <button class="btn btn-secondary btn-full" id="addPlayerBtn">+ Aggiungi Giocatore</button>             
                <button class="btn btn-primary btn-full" id="saveGameBtn" style="margin-top: var(--spacing-lg);">Salva Partita</button>
                <div id="alert"></div>
            </div>
        </div>

        <!-- TAB: Classifica -->
        <div id="classifica" class="tab-content">
            <div class="card">
                <div class="form-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-md); margin-bottom: var(--spacing-lg);">
                    <div>
                        <label for="classificationStartDate">Data Inizio</label>
                        <input type="date" id="classificationStartDate"/>
                    </div>
                    <div>
                        <label for="classificationEndDate">Data Fine</label>
                        <input type="date" id="classificationEndDate"/>
                    </div>
                </div>

                <h1>Risultati Relativi</h1>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    I risultati relativi mostrano i punti e i piazzamenti tenendo conto del numero di partite giocate.</p>

                <h2>Podio Relativo</h2>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    Il podio relativo viene calcolato dividendo il numero di piazzamenti ottenuti per il numero di partite giocate.</p>
                <div class="podium-grid" id="relativePodium">
                    <div class="podium-card">
                        <h3>ü•á Primi Posti</h3>
                        <ul class="podium-list" id="firstRelPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•à Secondi Posti</h3>
                        <ul class="podium-list" id="secondRelPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•â Terzi Posti</h3>
                        <ul class="podium-list" id="thirdRelPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•¥ Ultimi Posti</h3>
                        <ul class="podium-list" id="lastRelPlaceList"></ul>
                    </div>
                </div>
                
                <h2>Classifica Relativa</h2>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    Il punteggio viene calcolato sommando i punti ottenuti in ogni partita e dividendolo per le partite giocate.</p>
                <table class="leaderboard-table" id="relativeClassification">
                    <thead>
                        <tr>
                            <th>Posizione</th>
                            <th>Giocatore</th>
                            <th>Punti/Partite</th>
                            <th>Partite (%)</th>
                        </tr>
                    </thead>
                    <tbody id="relativeClassificationBody">
                    </tbody>
                </table>

                <h2>Evoluzione Classifica Relativa</h2>
                <div class="chart-wrapper">
                    <canvas id="relativeClassificationEvolution"></canvas>
                </div>

                <hr style="margin: 20px 0; border: 1px solid var(--color-border);" />
                
                <h1>Risultati Assoluti</h1>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    I risultati assoluti mostrano i punti e i piazzamenti senza tenere conto del numero di partite giocate.</p>
                <h2>Podio Assoluto</h2>
                 <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    Il podio assoluto mostra i piazzamenti ottenuti senza tenere conto del numero di partite giocate.</p>
                <div class="podium-grid" id="absolutePodium">
                    <div class="podium-card">
                        <h3>ü•á Primi Posti</h3>
                        <ul class="podium-list" id="firstAbsPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•à Secondi Posti</h3>
                        <ul class="podium-list" id="secondAbsPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•â Terzi Posti</h3>
                        <ul class="podium-list" id="thirdAbsPlaceList"></ul>
                    </div>
                    <div class="podium-card">
                        <h3>ü•¥ Ultimi Posti</h3>
                        <ul class="podium-list" id="lastAbsPlaceList"></ul>
                    </div>
                </div>

                <h2>Classifica Assoluta</h2>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">
                    Il punteggio viene calcolato sommando i punti ottenuti in ogni partita.</p>
                <table class="leaderboard-table" id="absoluteClassification">
                    <thead>
                        <tr>
                            <th>Posizione</th>
                            <th>Giocatore</th>
                            <th>Punti Totali</th>
                            <th>Partite (%)</th>
                        </tr>
                    </thead>
                    <tbody id="absoluteClassificationBody">
                    </tbody>
                </table>

                <h2>Evoluzione Classifica</h2>
                <div class="chart-wrapper">
                    <canvas id="absoluteClassificationEvolution"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB: Giocatori -->
        <div id="giocatori" class="tab-content">
            <div class="card">
                <h2>Gestione Giocatori</h2>
                <p style="color: var(--color-text-light); margin-bottom: var(--spacing-lg);">Aggiungi o rimuovi giocatori dal database. Questi nomi appariranno nel menu a tendina quando crei una nuova partita.</p>
                
                <div class="add-player-form">
                    <input type="text" id="newPlayerName" placeholder="Nome nuovo giocatore" />
                    <button class="btn btn-primary" id="addPlayerNameBtn">Aggiungi</button>
                </div>
                
                <h3>Giocatori Salvati (<span id="playerCount">0</span>)</h3>
                <div class="player-name-list" id="playerNameList"></div>
            </div>
        </div>

        <!-- TAB: Storico -->
        <div id="storico" class="tab-content">
            <div class="card">
                    <h2>Tabellone</h2>
                <div style="overflow-x: auto; margin-bottom: var(--spacing-lg);">
                    <table class="participation-table" id="participationTable">
                        <thead id="participationTableHead">
                            <!-- Table header will be generated by JavaScript -->
                        </thead>
                        <tbody id="participationTableBody">
                            <!-- Table body will be generated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <style>
                .participation-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin-bottom: var(--spacing-lg);
                    font-size: 14px;
                }

                .participation-table thead {
                    background-color: var(--color-primary);
                    color: white;
                    position: sticky;
                    top: 0;
                }

                .participation-table th {
                    padding: 12px 8px;
                    text-align: center;
                    border-bottom: 2px solid var(--color-primary);
                    font-weight: 600;
                    min-width: 60px;
                    white-space: nowrap;
                }

                .participation-table th:first-child {
                    min-width: 100px;
                    text-align: left;
                }

                .participation-table td {
                    padding: 12px 8px;
                    text-align: center;
                    border-bottom: 1px solid var(--color-border);
                }

                .participation-table td:first-child {
                    text-align: left;
                    font-weight: 500;
                }

                .participation-badge {
                    width: 40px;
                    height: 40px;
                    border-radius: 50%;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    font-weight: 600;
                    font-size: 12px;
                    margin: 0 auto;
                }

                .participation-badge.played {
                    background-color: var(--color-primary);
                    color: white;
                }

                .participation-badge.not-played {
                    background-color: #e0e0e0;
                    color: #999;
                }

                .participation-badge.first-place {
                    background-color: var(--color-gold);
                    color: white;
                }

                .participation-badge.second-place {
                    background-color: var(--color-silver);
                    color: white;
                }

                .participation-badge.third-place {
                    background-color: var(--color-bronze);
                    color: white;
                }

                .participation-badge.last-place {
                    background-color: var(--color-last);
                    color: white;
                }

                .participation-table tbody tr:hover {
                    background-color: #f9f9f9;
                }
                </style> 
                <h2>Storico Partite</h2>
                <div id="gameHistoryList"></div>
            </div>
        </div>
    </div>
        
        

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyACeAZdXhecfxCajTr03Byg_vAJd1y_p0Q",
            authDomain: "perudo-leaderbord.firebaseapp.com",
            databaseURL: "https://perudo-leaderbord-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "perudo-leaderbord",
            storageBucket: "perudo-leaderbord.firebasestorage.app",
            messagingSenderId: "804345086496",
            appId: "1:804345086496:web:6fb56a7f5546a88c027245"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        // State management
        let players = [];
        let games = [];
        let savedPlayerNames = [];
        let isOnline = true;

        // Initialize app
        function initApp() {
            // Non caricare pi√π da localStorage - solo da Firebase
            console.log('Inizializzazione app - caricamento dati da Firebase...');
            
            setDefaultDate();
            renderPlayerInputs();
            loadFromFirebase();
            setupFirebaseListeners();
            updateSyncStatus();
            setStartDate();
            setEndDate();
            updateDashboard();
            updateParticipationTable();
            updateAllPlayersList();
        }

        // Firebase Functions
        function loadFromFirebase() {
            console.log('Caricamento dati da Firebase...');
            
            // First, load player names
            db.ref('playerNames').once('value').then(snapshot => {
                if (snapshot.exists()) {
                    savedPlayerNames = Object.values(snapshot.val()).sort();
                    console.log('Giocatori caricati:', savedPlayerNames.length);
                } else {
                    savedPlayerNames = [];
                    console.log('Nessun giocatore salvato');
                }
                updatePlayerNameList();
                renderPlayerInputs();
                
                // Then load games after player names are loaded
                return db.ref('games').once('value');
            }).then(snapshot => {
                if (snapshot.exists()) {
                    games = Object.values(snapshot.val());
                    console.log('Partite caricate:', games.length);
                } else {
                    games = [];
                    console.log('Nessuna partita trovata');
                }
                extractPlayerNamesFromGames();
                updateGameHistory();
                updateDashboard();
                
                // Update participation table AFTER both player names and games are loaded
                updateDashboard();
                updateAllPlayersList();
                updateSyncStatus();
            }).catch(error => {
                console.error('Errore caricamento dati:', error);
                updateSyncStatus();
            });
        }

        function setupFirebaseListeners() {
            // Listener in tempo reale per le partite
            db.ref('games').on('value', snapshot => {
                console.log('Aggiornamento partite ricevuto da Firebase');
                if (snapshot.exists()) {
                    games = Object.values(snapshot.val());
                    console.log('Partite aggiornate:', games.length);
                } else {
                    games = [];
                }
                extractPlayerNamesFromGames();
                updateGameHistory();
                updateDashboard();
            }, error => {
                console.error('Errore listener partite:', error);
            });
            
            // Listener in tempo reale per i nomi giocatori
            db.ref('playerNames').on('value', snapshot => {
                console.log('Aggiornamento giocatori ricevuto da Firebase');
                if (snapshot.exists()) {
                    savedPlayerNames = Object.values(snapshot.val()).sort();
                    console.log('Giocatori aggiornati:', savedPlayerNames.length);
                } else {
                    savedPlayerNames = [];
                }
                updatePlayerNameList();
                renderPlayerInputs();
            }, error => {
                console.error('Errore listener giocatori:', error);
            });

            // Connessione
            db.ref('.info/connected').on('value', snap => {
                isOnline = snap.val();
                console.log('Stato connessione:', isOnline ? 'ONLINE' : 'OFFLINE');
                updateSyncStatus();
                
                // Se torniamo online, ricarica i dati
                if (isOnline) {
                    console.log('Riconnesso - ricarico dati...');
                    loadFromFirebase();
                }
            });
        }
        
        function extractPlayerNamesFromGames() {
            // Extract all unique player names from game history
            const namesFromGames = new Set();
            games.forEach(game => {
                if (game.results) {
                    game.results.forEach(result => {
                        if (result.playerName && result.playerName.trim()) {
                            namesFromGames.add(result.playerName.trim());
                        }
                    });
                }
            });
            
            // Merge with existing saved names
            let hasNewNames = false;
            namesFromGames.forEach(name => {
                if (!savedPlayerNames.includes(name)) {
                    savedPlayerNames.push(name);
                    hasNewNames = true;
                }
            });
            
            if (hasNewNames) {
                savedPlayerNames.sort();
                savePlayerNamesToFirebase();
            }
        }

        function updateSyncStatus() {
            const status = document.getElementById('syncStatus');
            if (isOnline) {
                status.innerHTML = '‚úì Sincronizzato <button onclick="forceRefresh()" style="margin-left: 8px; padding: 2px 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); border-radius: 4px; color: white; cursor: pointer; font-size: 10px;">üîÑ Aggiorna</button>';
                status.className = 'sync-status synced';
            } else {
                status.textContent = '‚ö† Offline';
                status.className = 'sync-status';
            }
        }
        
        function forceRefresh() {
            console.log('Aggiornamento forzato richiesto...');
            const status = document.getElementById('syncStatus');
            status.textContent = '‚ü≥ Aggiornamento in corso...';
            
            // Forza il reload completo da Firebase
            Promise.all([
                db.ref('games').once('value'),
                db.ref('playerNames').once('value')
            ]).then(([gamesSnapshot, playersSnapshot]) => {
                // Aggiorna partite
                if (gamesSnapshot.exists()) {
                    games = Object.values(gamesSnapshot.val());
                    console.log('Partite aggiornate:', games.length);
                } else {
                    games = [];
                }
                
                // Aggiorna giocatori
                if (playersSnapshot.exists()) {
                    savedPlayerNames = Object.values(playersSnapshot.val()).sort();
                    console.log('Giocatori aggiornati:', savedPlayerNames.length);
                } else {
                    savedPlayerNames = [];
                }
                extractPlayerNamesFromGames();
                updateGameHistory();
                updateDashboard();
                updatePlayerNameList();
                renderPlayerInputs();
                updateSyncStatus();
                
                // Mostra conferma
                setTimeout(() => {
                    const currentStatus = document.getElementById('syncStatus');
                    currentStatus.textContent = '‚úì Aggiornato!';
                    setTimeout(() => updateSyncStatus(), 2000);
                }, 500);
            }).catch(error => {
                console.error('Errore aggiornamento:', error);
                status.textContent = '‚úó Errore aggiornamento';
                setTimeout(() => updateSyncStatus(), 3000);
            });
        }

        function setDefaultDate() {
            const today = new Date().toISOString().split('T')[0];
            const dateInput = document.getElementById('gameDate');
            dateInput.value = today;
            checkDateAvailability(today);
            
            // Add event listener for date changes
            dateInput.addEventListener('change', function() {
                checkDateAvailability(this.value);
            });
        }

        function setStartDate() {
            const today = new Date();
            // Use local date formatting instead of ISO to avoid timezone issues
            const startOfYear = `${today.getFullYear()}-01-01`;
            const dateInput = document.getElementById('classificationStartDate');
            dateInput.value = startOfYear;
            
            // Add event listener for date changes
            dateInput.addEventListener('change', function() {
                updateDashboard();
            });
        }

        function setEndDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            const localDate = `${year}-${month}-${day}`;
            
            const dateInput = document.getElementById('classificationEndDate');
            dateInput.value = localDate;
            
            // Add event listener for date changes
            dateInput.addEventListener('change', function() {
                updateDashboard();
            });
        }
        
        function checkDateAvailability(date) {
            const dateAlert = document.getElementById('dateAlert');
            if (!date) {
                dateAlert.innerHTML = '';
                return;
            }
            
            const existingGame = games.find(g => g.date === date);
            if (existingGame) {
                dateAlert.innerHTML = '<div class="alert alert-warning">‚ö†Ô∏è Esiste gi√† una partita per questa data. Puoi eliminarla dallo storico se vuoi sostituirla.</div>';
            } else {
                dateAlert.innerHTML = '';
            }
        }

        // Tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                const tabId = e.target.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
                if (tabId === 'home') updateAllPlayersList();
                if (tabId === 'classifica') updateDashboard();
                if (tabId === 'storico') updateGameHistory();
                if (tabId === 'giocatori') updatePlayerNameList();
            });
        });

        // Player management
        function addPlayerInput() {
            players.push({ id: Date.now(), name: '', nd: '' });
            renderPlayerInputs();
        }

        function removePlayer(id) {
            players = players.filter(p => p.id !== id);
            renderPlayerInputs();
        }

        function renderPlayerInputs() {
            const list = document.getElementById('playersList');
            
            list.innerHTML = players.map((player, index) => {
                const totalPlayers = players.length;
                let bgColor = 'var(--color-success)';
                
                if (index === 0) {
                    bgColor = 'var(--color-gold)';
                } else if (index === 1) {
                    bgColor = 'var(--color-silver)';
                } else if (index === 2) {
                    if (totalPlayers === 3) {
                        bgColor = 'var(--color-last)';
                    } else {
                        bgColor = 'var(--color-bronze)';
                    }
                } else if (index === totalPlayers - 1 && totalPlayers > 3) {
                    bgColor = 'var(--color-last)';
                }
                
                return `
                <div class="player-item">
                    <div class="player-input-wrapper">
                        <select 
                            data-player-id="${player.id}"
                            class="player-name-select"
                        >
                            <option value="">Seleziona giocatore...</option>
                            ${savedPlayerNames.map(name => `
                                <option value="${name}" ${player.name === name ? 'selected' : ''}>${name}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div class="form-group" style="margin: 0; flex: 0 0 80px;">
                        <input 
                            type="number" 
                            min="0" 
                            max="999"
                            placeholder="Dadi"
                            data-player-id="${player.id}"
                            class="player-dice-input"
                            value="${player.nd || ''}"
                        />
                    </div>
                    <span style="padding: 8px 12px; background-color: ${bgColor}; color: white; border-radius: 4px; font-size: 12px; font-weight: 600;">${index + 1}¬∞</span>
                    <button type="button" data-player-id="${player.id}" class="player-remove-btn">Rimuovi</button>
                </div>
                `;
            }).reverse().join('');
            
            // Attach event listeners for select dropdowns
            document.querySelectorAll('.player-name-select').forEach(select => {
            select.addEventListener('change', function() {
            const playerId = parseInt(this.dataset.playerId);
            updatePlayerName(playerId, this.value);
            });
            });
            
            // Attach event listeners for dice inputs
            document.querySelectorAll('.player-dice-input').forEach(input => {
            input.addEventListener('change', function() {
            const playerId = parseInt(this.dataset.playerId);
            updatePlayerDice(playerId, this.value);
            });
            });
            
            // Attach event listeners for remove buttons
            document.querySelectorAll('.player-remove-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const playerId = parseInt(this.dataset.playerId);
            removePlayer(playerId);
            });
            });
        }

        function updatePlayerName(id, name) {
            const player = players.find(p => p.id === id);
            if (player) player.name = name;
        }

        function updatePlayerDice(id, dice) {
            const player = players.find(p => p.id === id);
            if (player) player.nd = dice;
        }

        // Points calculation
        function calculatePoints(p, ng, nds, ndv, isWinner) {
            if (isWinner) {
                return (1 - p / ng) * (1 + ndv / 10);
            } else {
                return (1 - p / ng) * (1 - nds / (5 * ng));
            }
        }

        // Save game
        function saveGame() {
            const alert = document.getElementById('alert');
            alert.innerHTML = '';

            const gameDate = document.getElementById('gameDate').value;
            if (!gameDate) {
            showAlert('Seleziona una data', 'error');
            return;
            }

            if (players.length === 0) {
            showAlert('Aggiungi almeno un giocatore', 'error');
            return;
            }
            
            // Check if a game already exists for this date
            const existingGame = games.find(g => g.date === gameDate);
            if (existingGame) {
            showAlert('Esiste gi√† una partita salvata per questa data. Elimina prima quella esistente o scegli un\'altra data.', 'error');
            return;
            }

            // Validate all players have name and dice
            let hasError = false;
            const playerNames = new Set();
            for (let player of players) {
                if (!player.name || player.name.trim() === '') {
                    showAlert('Tutti i giocatori devono avere un nome', 'error');
                    return;
                }
                if (player.nd === '' || isNaN(player.nd)) {
                    showAlert('Tutti i giocatori devono avere un numero di dadi', 'error');
                    return;
                }
                if (playerNames.has(player.name)) {
                    showAlert(`I nomi dei giocatori devono essere unici. \nControlla \"${player.name}\"`, 'error');
                    return;
                }
                playerNames.add(player.name);
            }

            const gameResults = [];
            const ng = players.length;

            // Manually set the order of players based on their dice count
            const sortedPlayers = players.filter(p => p.nd !== '').map(p => ({ ...p, nd: parseInt(p.nd) }));

            // Verify that the order of dice for players is ascending
            const isOrderValid = sortedPlayers.every((player, index) => {
                return index === 0 || player.nd >= sortedPlayers[index - 1].nd;
            });

            if (!isOrderValid) {
                showAlert('I dadi devono essere in ordine decrescente', 'error');
                return;
            }

            // Verify minimum number of players
            if (sortedPlayers.length < 3) {
                showAlert('Sono necessari almeno 3 giocatori per salvare una partita', 'error');
                return;
            }
            
            // Verify that dice count doesn't exceed maximum allowed per position
            for (let i = 0; i < sortedPlayers.length; i++) {
                // First place can have up to 5 dice
                // Other places can have up to (position-1) * 5 dice
                const maxDiceAllowed = Math.max(i, 1) * 5; 
                if (sortedPlayers[i].nd > maxDiceAllowed) {
                    showAlert(`${sortedPlayers[i].name} ha troppi dadi. Massimo consentito per ${i + 1}¬∞ la posizione: ${maxDiceAllowed}`, 'error');
                    return;
                }
            }

            // Verify first and second have the same dice count
            if (sortedPlayers.length < 2 || sortedPlayers[0].nd !== sortedPlayers[1].nd) {
                showAlert('Primo e secondo devono avere lo stesso numero di dadi', 'error');
                return;
            }

            // Verify all other players have different dice counts
            for (let i = 1; i < sortedPlayers.length - 1; i++) {
            if (sortedPlayers[i].nd === sortedPlayers[i + 1].nd) {
                showAlert('Ogni giocatore (eccetto primo e secondo) deve avere un numero di dadi diverso', 'error');
                return;
            }
            }

            // Create results for all players based on sorted order
            sortedPlayers.forEach((player, index) => {
            const position = index + 1;
            const isWinner = position === 1;
            const ndv = isWinner ? player.nd : 0; // Winner's dice
            const nds = !isWinner ? player.nd : 0; // Loser's dice
            
            gameResults.push({
                playerId: player.id,
                playerName: player.name,
                position: position,
                nds: nds,
                ndv: ndv,
                points: calculatePoints(position, ng, nds, ndv, isWinner),
                isWinner: isWinner
            });
            });

            const game = {
            id: Date.now(),
            date: gameDate,
            players: players.map(p => p.name),
            results: gameResults
            };

            saveData(game);
            showAlert('Partita salvata con successo!', 'success');

            // Reset form
            setTimeout(() => {
                players = [];
                renderPlayerInputs();
                setDefaultDate();
                updateDashboard();
                updateGameHistory();
            }, 1500);
        }

        function showAlert(message, type) {
            const alert = document.getElementById('alert');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
        }

        // Data persistence
        function saveData(game) {
            // Aggiungi partita all'array locale (temporaneo)
            games.push(game);
            
            // Add player names to saved names
            game.players.forEach(playerName => {
                if (playerName && !savedPlayerNames.includes(playerName)) {
                    savedPlayerNames.push(playerName);
                }
            });
            savedPlayerNames.sort();
            
            // Salva giocatori su Firebase
            savePlayerNamesToFirebase();
            
            // Salva partita su Firebase (unica fonte di verit√†)
            db.ref('games/' + game.id).set(game).then(() => {
                console.log('Partita salvata su Firebase con successo');
            }).catch(error => {
                console.error('Errore salvataggio partita:', error);
                showAlert('Errore di sincronizzazione', 'error');
            });
        }
        
        function savePlayerNamesToFirebase() {
            console.log('Salvataggio giocatori su Firebase...', savedPlayerNames.length);
            
            // Converti array in oggetto per Firebase
            const playersObj = {};
            savedPlayerNames.forEach((name, index) => {
                playersObj[index] = name;
            });
            
            db.ref('playerNames').set(playersObj).then(() => {
                console.log('Giocatori salvati con successo');
            }).catch(error => {
                console.error('Errore salvataggio giocatori:', error);
            });
        }
        
        
        // Dashboard and Statistics
        let chartInstances = {};
        
        function updateDashboard() {
            // Get date range from inputs
            const startDate = document.getElementById('classificationStartDate')?.value;
            const endDate = document.getElementById('classificationEndDate')?.value;
            
            // Filter games by date range
            const filteredGames = games.filter(game => {
                if (!game.date) return false;
                if (startDate && game.date < startDate) return false;
                if (endDate && game.date > endDate) return false;
                return true;
            });
            
            // Pass filtered games to update functions instead of modifying global
            updateParticipationTable(filteredGames);
            updateRelativePodiumStats(filteredGames);
            updateRelativeClassification(filteredGames);
            updateRelativeClassificationEvolutionChart(filteredGames);
            updateAbsolutePodiumStats(filteredGames);
            updateAbsoluteClassification(filteredGames);
            updateAbsoluteClassificationEvolutionChart(filteredGames);
        }

        function updateParticipationTable(games) {
            if (games.length === 0 || savedPlayerNames.length === 0) {
                const thead = document.getElementById('participationTableHead');
                const tbody = document.getElementById('participationTableBody');
                if (thead) thead.innerHTML = '';
                if (tbody) tbody.innerHTML = '<tr><td colspan="100" class="empty-state">Nessuna partita ancora</td></tr>';
                return;
            }
            
            // Build table header dynamically
            const thead = document.getElementById('participationTableHead');
            thead.innerHTML = `
                <tr>
                    <th>Data</th>
                    ${savedPlayerNames.map(name => {
                        const parts = name.trim().split(/\s+/);
                        return `<th>${parts.join('<br>')}</th>`;
                    }).join('')}
                </tr>
            `;
            
            // Get all unique dates and sort them
            const dates = [...new Set(games.map(g => g.date))].sort().reverse();
            
            // Build table body
            const tbody = document.getElementById('participationTableBody');
            tbody.innerHTML = dates.map(date => {
                const game = games.find(g => g.date === date);
                const dateStr = new Date(date).toLocaleDateString('it-IT');
                
                return `
                    <tr>
                        <td>${dateStr}</td>
                        ${savedPlayerNames.map(playerName => {
                            const result = game?.results?.find(r => r.playerName === playerName);
                            if (result) {
                                const maxPosition = Math.max(...game.results.map(r => r.position));
                                const badgeClass =  result.position === maxPosition ? 'last-place' : 
                                                    result.position === 1 ? 'first-place' :
                                                    result.position === 2 ? 'second-place' :
                                                    result.position === 3 ? 'third-place' : 
                                                    'played';
                                return `<td><span class="participation-badge ${badgeClass}">${result.position}¬∞</span></td>`;
                            } else {
                                return `<td><span class="participation-badge not-played">NA</span></td>`;
                            }
                        }).join('')}
                    </tr>
                `;
            }).join('');
        }

        function updateRelativePodiumStats(games) {
            const positionCounts = { 1: {}, 2: {}, 3: {}, last: {} };
            const playerGamesCount = {};

            
            games.forEach(game => {
            if (game.results && game.results.length > 0) {
            // Find the maximum position in this game (actual last place)
            const maxPosition = Math.max(...game.results.map(r => r.position));
            
            game.results.forEach(result => {
            playerGamesCount[result.playerName] = (playerGamesCount[result.playerName] || 0) + 1;

            if (result.position === 1) {
                positionCounts[1][result.playerName] = (positionCounts[1][result.playerName] || 0) + 1;
            } else if (result.position === 2) {
                positionCounts[2][result.playerName] = (positionCounts[2][result.playerName] || 0) + 1;
            } else if (result.position === 3) {
                positionCounts[3][result.playerName] = (positionCounts[3][result.playerName] || 0) + 1;
            } 
            if (result.position === maxPosition) {
                positionCounts.last[result.playerName] = (positionCounts.last[result.playerName] || 0) + 1;
            }
            });
            }
            });

            // Convert counts to percentages based on total games played by each player
            const percentagePositions = {
            1: {},
            2: {},
            3: {},
            last: {}
            };

            Object.keys(positionCounts).forEach(pos => {
            Object.entries(positionCounts[pos]).forEach(([name, count]) => {
            const totalGames = playerGamesCount[name] || 1;
            const percentage = Math.floor((count / totalGames) * 100);
            if (!percentagePositions[pos]) {
            percentagePositions[pos] = {};
            }
            percentagePositions[pos][name] = percentage;
            });
            });

            // Sort and group by percentage for each position
            const sortedPositions = {
            1: {},
            2: {},
            3: {},
            last: {}
            };

            Object.keys(percentagePositions).forEach(pos => {
            // Group players by percentage
            const groupedByPercentage = {};
            Object.entries(percentagePositions[pos]).forEach(([name, percentage]) => {
            if (!groupedByPercentage[percentage]) {
            groupedByPercentage[percentage] = [];
            }
            groupedByPercentage[percentage].push(name);
            });

            // Sort percentages descending
            const sortedPercentages = Object.keys(groupedByPercentage)
            .map(Number)
            .sort((a, b) => b - a);

            // Always show 5 percentage entries (pad with empty if needed)
            const displayPercentages = sortedPercentages.slice(0, 5);
            while (displayPercentages.length < 5) {
            displayPercentages.push(null);
            }

            // Build result object with grouped names
            displayPercentages.forEach(percentage => {
            if (percentage !== null && groupedByPercentage[percentage]) {
                const names = groupedByPercentage[percentage].sort();
                sortedPositions[pos][names.join('<br>')] = percentage;
            } else if (percentage === null) {
                sortedPositions[pos]['-'] = '-';
            }
            });
            });

            // Update podium lists
            updateRelPodiumList('firstRelPlaceList', sortedPositions[1]);
            updateRelPodiumList('secondRelPlaceList', sortedPositions[2]);
            updateRelPodiumList('thirdRelPlaceList', sortedPositions[3]);
            updateRelPodiumList('lastRelPlaceList', sortedPositions.last);
        }

        function updateRelPodiumList(listId, positionData) {
            const list = document.getElementById(listId);
            list.innerHTML = Object.entries(positionData)
            .map(([name, percentage]) => {
            if (percentage === '-') {
            return `<li style="color: #999;">-</li>`;
            }
            return `<li style="display: flex; justify-content: space-between; align-items: center;">
            <span class="player-name">${name}</span>
            <span class="percentage" style="color: #eeeeee; font-weight: bold; border-radius: 50%; padding: 0; background-color: var(--color-primary); width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 12px;">${percentage}%</span>
            </li>`;
            })
            .join('') || '<li style="color: #999;">Nessun dato</li>';
        }

        function updateRelativeClassification(games) {
            const relativeClassificationBody = document.getElementById('relativeClassificationBody');
            
            if (games.length === 0) {
            relativeClassificationBody.innerHTML = '<tr><td colspan="4" class="empty-state">Nessuna partita ancora</td></tr>';
            return;
            }

            const playerStats = {};
            let totalGames = 0;

            games.forEach(game => {
            if (game.results) {
                totalGames++;
                game.results.forEach(result => {
                if (!playerStats[result.playerName]) {
                    playerStats[result.playerName] = { points: 0, games: 0 };
                }
                playerStats[result.playerName].points += result.points;
                playerStats[result.playerName].games += 1;
                });
            }
            });

            const sorted = Object.entries(playerStats)
            .map(([name, stats]) => ({ 
                name, 
                ...stats, 
                avgPoints: stats.points / stats.games,
                playedPercentage: (stats.games / totalGames) * 100
            }))
            .sort((a, b) => b.avgPoints - a.avgPoints);

            relativeClassificationBody.innerHTML = sorted.map((player, index) => `
            <tr>
                <td class="rank">#${index + 1}</td>
                <td>${player.name}</td>
                <td class="points ${player.avgPoints >= 0 ? 'positive' : 'negative'}">
                ${player.avgPoints.toFixed(3)}
                </td>
                <td>${player.games} (${player.playedPercentage.toFixed(1)}%)</td>
            </tr>
            `).join('');
        }
        
        function updateRelativeClassificationEvolutionChart(games) {
            // Sort games by date
            const sortedGames = [...games].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Get all unique dates
            const allDates = [...new Set(sortedGames.map(g => g.date))].sort();
            
            // Track cumulative points and games played for each player
            const playerStats = {};
            const playerEvolution = {};
            const dateLabels = [];
            
            // Initialize all players
            savedPlayerNames.forEach(playerName => {
            playerStats[playerName] = { points: 0, games: 0 };
            playerEvolution[playerName] = [];
            });
            
            // Process each date
            allDates.forEach((date) => {
            dateLabels.push(new Date(date).toLocaleDateString('it-IT', { month: 'short', day: 'numeric' }));
            
            // Find game for this date if it exists
            const gameForDate = sortedGames.find(g => g.date === date);
            
            if (gameForDate && gameForDate.results) {
                // Update cumulative points and games for players who played
                gameForDate.results.forEach(result => {
                if (playerStats.hasOwnProperty(result.playerName)) {
                    playerStats[result.playerName].points += result.points;
                    playerStats[result.playerName].games += 1;
                }
                });
            }
            
            // Rank ALL players by average points (relative: total points / games played)
            const ranked = Object.entries(playerStats)
                .map(([name, stats]) => ({ 
                name, 
                avgPoints: stats.games > 0 ? stats.points / stats.games : 0,
                games: stats.games
                }))
                .sort((a, b) => {
                // Sort by average points descending, then by games played descending
                if (b.avgPoints !== a.avgPoints) return b.avgPoints - a.avgPoints;
                return b.games - a.games;
                })
                .map((player, index) => ({ ...player, rank: index + 1 }));
            
            // Record rank for each player at this date
            savedPlayerNames.forEach(playerName => {
                const playerRank = ranked.find(r => r.name === playerName);
                playerEvolution[playerName].push(playerRank ? playerRank.rank : null);
            });
            });
            
            // Get top 15 players by final rank
            const topPlayers = Object.entries(playerEvolution)
            .map(([name, ranks]) => ({ name, finalRank: ranks[ranks.length - 1] || null }))
            .filter(p => p.finalRank !== null)
            .sort((a, b) => a.finalRank - b.finalRank)
            .slice(0, 15)
            .map(p => p.name);
            
            const colors = [
            'rgba(27, 158, 119, 1)',
            'rgba(217, 95, 2, 1)',
            'rgba(117, 112, 179, 1)',
            'rgba(231, 41, 137, 1)',
            'rgba(102, 166, 30, 1)'
            ];

            const dashes = [[], [10, 10], [1, 1]];            
            
            const datasets = topPlayers.map((playerName, index) => ({
            label: playerName,
            data: playerEvolution[playerName],
            borderColor: colors[index % colors.length],
            backgroundColor: colors[index % colors.length].replace('1)', '0.1)'),
            borderDash: dashes[index % dashes.length],
            borderWidth: 2,
            tension: 0.1,
            fill: false
            }));
            
            const ctx = document.getElementById('relativeClassificationEvolution');
            if (!ctx) return;
            
            // Destroy existing chart
            if (chartInstances.relativeEvolution) {
            chartInstances.relativeEvolution.destroy();
            }
            
            chartInstances.relativeEvolution = new Chart(ctx, {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
                },
                scales: {
                y: {
                    beginAtZero: false,
                    reverse: true,
                    ticks: {
                    stepSize: 1
                    },
                    title: {
                    display: true,
                    text: 'Ranking'
                    }
                }
                },
                interaction: {
                mode: 'index',
                intersect: false
                }
            }
            });
        }

        function updateAbsolutePodiumStats(games) {
            const positionCounts = { 1: {}, 2: {}, 3: {}, last: {} };

            games.forEach(game => {
            if (game.results && game.results.length > 0) {
            // Find the maximum position in this game (actual last place)
            const maxPosition = Math.max(...game.results.map(r => r.position));
            
            game.results.forEach(result => {
            if (result.position === 1) {
            positionCounts[1][result.playerName] = (positionCounts[1][result.playerName] || 0) + 1;
            } else if (result.position === 2) {
            positionCounts[2][result.playerName] = (positionCounts[2][result.playerName] || 0) + 1;
            } else if (result.position === 3) {
            positionCounts[3][result.playerName] = (positionCounts[3][result.playerName] || 0) + 1;
            } 
            if (result.position === maxPosition) {
            positionCounts.last[result.playerName] = (positionCounts.last[result.playerName] || 0) + 1;
            }
            });
            }
            });

            // Sort and group by count for each position
            const sortedPositions = {
            1: {},
            2: {},
            3: {},
            last: {}
            };

            Object.keys(positionCounts).forEach(pos => {
            // Group players by count
            const groupedByCount = {};
            Object.entries(positionCounts[pos]).forEach(([name, count]) => {
            if (!groupedByCount[count]) {
            groupedByCount[count] = [];
            }
            groupedByCount[count].push(name);
            });

            // Sort counts descending
            const sortedCounts = Object.keys(groupedByCount)
            .map(Number)
            .sort((a, b) => b - a);

            // Always show 5 count entries (pad with empty if needed)
            const displayCounts = sortedCounts.slice(0, 5);
            while (displayCounts.length < 5) {
            displayCounts.push(null);
            }

            // Build result object with grouped names
            displayCounts.forEach(count => {
            if (count !== null && groupedByCount[count]) {
            const names = groupedByCount[count].sort();
            sortedPositions[pos][names.join('<br>')] = count;
            } else if (count === null) {
            sortedPositions[pos]['-'] = '-';
            }
            });
            });

            // Update podium lists
            updateAbsPodiumList('firstAbsPlaceList', sortedPositions[1]);
            updateAbsPodiumList('secondAbsPlaceList', sortedPositions[2]);
            updateAbsPodiumList('thirdAbsPlaceList', sortedPositions[3]);
            updateAbsPodiumList('lastAbsPlaceList', sortedPositions.last);
        }

        function updateAbsPodiumList(listId, positionData) {
            const list = document.getElementById(listId);
            list.innerHTML = Object.entries(positionData)
            .map(([name, count]) => {
            if (count === '-') {
            return `<li style="color: #999;">-</li>`;
            }
            return `<li style="display: flex; justify-content: space-between; align-items: center;">
            <span class="player-name">${name}</span>
            <span class="count" style="color: #eeeeee; font-weight: bold; border-radius: 50%; padding: 0; background-color: var(--color-primary); width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-size: 12px;">${count}</span>
            </li>`;
            })
            .join('') || '<li style="color: #999;">Nessun dato</li>';
        }

        function updateAbsoluteClassification(games) {
            const absoluteClassificationBody = document.getElementById('absoluteClassificationBody');
            
            if (games.length === 0) {
            absoluteClassificationBody.innerHTML = '<tr><td colspan="4" class="empty-state">Nessuna partita ancora</td></tr>';
            return;
            }

            const playerStats = {};
            let totalGames = 0;

            games.forEach(game => {
            if (game.results) {
                totalGames++;
                game.results.forEach(result => {
                if (!playerStats[result.playerName]) {
                    playerStats[result.playerName] = { points: 0, games: 0 };
                }
                playerStats[result.playerName].points += result.points;
                playerStats[result.playerName].games += 1;
                });
            }
            });

            const sorted = Object.entries(playerStats)
            .map(([name, stats]) => ({ 
                name, 
                ...stats,
                playedPercentage: (stats.games / totalGames) * 100
            }))
            .sort((a, b) => b.points - a.points);

            absoluteClassificationBody.innerHTML = sorted.map((player, index) => `
            <tr>
                <td class="rank">#${index + 1}</td>
                <td>${player.name}</td>
                <td class="points ${player.points >= 0 ? 'positive' : 'negative'}">
                ${player.points.toFixed(2)}
                </td>
                <td>${player.games} (${player.playedPercentage.toFixed(1)}%)</td>
            </tr>
            `).join('');
        }
        
        function updateAbsoluteClassificationEvolutionChart(games) {
            // Sort games by date
            const sortedGames = [...games].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            // Get all unique dates
            const allDates = [...new Set(sortedGames.map(g => g.date))].sort();
            
            // Track cumulative points for each player
            const playerCumulativePoints = {};
            const playerEvolution = {};
            const dateLabels = [];
            
            // Initialize all players
            savedPlayerNames.forEach(playerName => {
            playerCumulativePoints[playerName] = 0;
            playerEvolution[playerName] = [];
            });
            
            // Process each date
            allDates.forEach((date) => {
            dateLabels.push(new Date(date).toLocaleDateString('it-IT', { month: 'short', day: 'numeric' }));
            
            // Find game for this date if it exists
            const gameForDate = sortedGames.find(g => g.date === date);
            
            if (gameForDate && gameForDate.results) {
                // Update cumulative points for players who played
                gameForDate.results.forEach(result => {
                if (playerCumulativePoints.hasOwnProperty(result.playerName)) {
                    playerCumulativePoints[result.playerName] += result.points;
                }
                });
            }
            
            // Rank ALL players by cumulative points (including those who didn't play today)
            const ranked = Object.entries(playerCumulativePoints)
                .map(([name, points]) => ({ name, totalPoints: points }))
                .sort((a, b) => b.totalPoints - a.totalPoints)
                .map((player, index) => ({ ...player, rank: index + 1 }));
            
            // Record rank for each player at this date
            savedPlayerNames.forEach(playerName => {
                const playerRank = ranked.find(r => r.name === playerName);
                playerEvolution[playerName].push(playerRank ? playerRank.rank : null);
            });
            });
            
            // Get top 10 players by final rank
            const topPlayers = Object.entries(playerEvolution)
            .map(([name, ranks]) => ({ name, finalRank: ranks[ranks.length - 1] || null }))
            .filter(p => p.finalRank !== null)
            .sort((a, b) => a.finalRank - b.finalRank)
            .slice(0, 15)
            .map(p => p.name);
            
             const colors = [
                'rgba(27, 158, 119, 1)',
                'rgba(217, 95, 2, 1)',
                'rgba(117, 112, 179, 1)',
                'rgba(231, 41, 137, 1)',
                'rgba(102, 166, 30, 1)'
            ];

            const dashes = [[], [10, 10], [1, 1]];            
            
            const datasets = topPlayers.map((playerName, index) => ({
            label: playerName,
            data: playerEvolution[playerName],
            borderColor: colors[index % colors.length],
            backgroundColor: colors[index % colors.length].replace('1)', '0.1)'),
            borderDash: dashes[index % dashes.length],
            borderWidth: 2,
            tension: 0.1,
            fill: false
            }));
            
            const ctx = document.getElementById('absoluteClassificationEvolution');
            if (!ctx) return;
            
            // Destroy existing chart
            if (chartInstances.absoluteEvolution) {
            chartInstances.absoluteEvolution.destroy();
            }
            
            chartInstances.absoluteEvolution = new Chart(ctx, {
            type: 'line',
            data: {
                labels: dateLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                legend: {
                    display: true,
                    position: 'top'
                }
                },
                scales: {
                y: {
                    beginAtZero: false,
                    reverse: true,
                    ticks: {
                    stepSize: 1
                    },
                    title: {
                    display: true,
                    text: 'Ranking'
                    }
                }
                },
                interaction: {
                mode: 'index',
                intersect: false
                }
            }
            });
        }
        
        // Game history
        function updateGameHistory() {
            const historyList = document.getElementById('gameHistoryList');
            
            if (games.length === 0) {
                historyList.innerHTML = '<div class="empty-state">Nessuna partita ancora</div>';
                return;
            }

            const sorted = [...games].sort((a, b) => new Date(b.date) - new Date(a.date));

            historyList.innerHTML = sorted.map(game => {
                // Ordina i risultati per posizione
                const sortedResults = [...game.results].sort((a, b) => a.position - b.position);
                
                return `
                <div class="game-card" onclick="toggleGameDetails(${game.id})" style="cursor: pointer;">
                    <button class="delete-game-btn" onclick="event.stopPropagation(); deleteGame(${game.id})" title="Elimina partita">√ó</button>
                    <h4>${new Date(game.date).toLocaleDateString('it-IT')}</h4>
                    <p><strong>Giocatori:</strong> ${game.players.join(', ')}</p>
                    <div class="game-card-result">
                        ${sortedResults.slice(0, 3).map(result => `
                            <div class="game-result-item">
                                <strong>${result.playerName}</strong><br>
                                Pos: ${result.position} | Dadi: ${result.nds || result.ndv} | Punti: ${result.points.toFixed(2)}
                            </div>
                        `).join('')}
                        ${sortedResults.length > 3 ? `
                            <div id="game-details-${game.id}" style="display: none;">
                                ${sortedResults.slice(3).map(result => `
                                    <div class="game-result-item">
                                        <strong>${result.playerName}</strong><br>
                                        Pos: ${result.position} | Dadi: ${result.nds || result.ndv} | Punti: ${result.points.toFixed(2)}
                                    </div>
                                `).join('')}
                            </div>
                            <div class="show-more-indicator" id="show-more-${game.id}">
                                <small style="color: var(--color-text-light); font-style: italic;">Clicca per vedere tutti i giocatori (${sortedResults.length - 3} nascosti)</small>
                            </div>
                        ` : ''}
                    </div>
                </div>
                `;
            }).join('');
        }
        
        function toggleGameDetails(gameId) {
            const detailsElement = document.getElementById(`game-details-${gameId}`);
            const indicatorElement = document.getElementById(`show-more-${gameId}`);
            
            if (detailsElement) {
                if (detailsElement.style.display === 'none') {
                    detailsElement.style.display = 'block';
                    if (indicatorElement) {
                        indicatorElement.innerHTML = '<small style="color: var(--color-text-light); font-style: italic;">Clicca per nascondere</small>';
                    }
                } else {
                    detailsElement.style.display = 'none';
                    if (indicatorElement) {
                        const hiddenCount = detailsElement.querySelectorAll('.game-result-item').length;
                        indicatorElement.innerHTML = `<small style="color: var(--color-text-light); font-style: italic;">Clicca per vedere tutti i giocatori (${hiddenCount} nascosti)</small>`;
                    }
                }
            }
        }
        
        function deleteGame(gameId) {
            if (!confirm('Sei sicuro di voler eliminare questa partita? Questa azione non pu√≤ essere annullata.')) {
                return;
            }
            
            // Remove from local array (temporaneo)
            games = games.filter(g => g.id !== gameId);
            
            // Remove from Firebase (unica fonte di verit√†)
            db.ref('games/' + gameId).remove().then(() => {
                console.log('Partita eliminata da Firebase con successo');
            }).catch(error => {
                console.error('Errore eliminazione da Firebase:', error);
                showAlert('Errore durante l\'eliminazione', 'error');
            });
            
            // Update all views
            updateGameHistory();
            updateleaderboard();
            updateDashboard();
            
            // Recheck date availability
            const currentDate = document.getElementById('gameDate')?.value;
            if (currentDate) {
                checkDateAvailability(currentDate);
            }
        }
        
        // Player name management
        function updatePlayerNameList() {
            const listDiv = document.getElementById('playerNameList');
            const countSpan = document.getElementById('playerCount');
            
            if (!listDiv || !countSpan) return;
            
            countSpan.textContent = savedPlayerNames.length;
            
            if (savedPlayerNames.length === 0) {
                listDiv.innerHTML = '<div class="empty-state" style="grid-column: 1/-1;">Nessun giocatore salvato</div>';
                return;
            }
            
            listDiv.innerHTML = savedPlayerNames.map(name => `
                <div class="player-name-tag" id="tag-${name.replace(/[^a-zA-Z0-9]/g, '_')}">
                    <span class="player-name-display">${name}</span>
                    <input type="text" class="player-name-edit" value="${name}" style="display: none;" />
                    <div class="button-group">
                        <button class="btn-edit" onclick="editPlayerName('${name.replace(/'/g, "\\'")}')" title="Modifica">‚úèÔ∏è</button>
                        <button class="btn-save" onclick="savePlayerName('${name.replace(/'/g, "\\'")}')" style="display: none;" title="Salva">‚úì</button>
                        <button class="btn-cancel" onclick="cancelEditPlayerName('${name.replace(/'/g, "\\'")}')" style="display: none;" title="Annulla">‚úï</button>
                        <button class="btn-delete" onclick="removePlayerName('${name.replace(/'/g, "\\'")}')" title="Elimina">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }
        
        function editPlayerName(name) {
            const tagId = 'tag-' + name.replace(/[^a-zA-Z0-9]/g, '_');
            const tag = document.getElementById(tagId);
            if (!tag) return;
            
            tag.classList.add('editing');
            tag.querySelector('.player-name-display').style.display = 'none';
            tag.querySelector('.player-name-edit').style.display = 'block';
            tag.querySelector('.btn-edit').style.display = 'none';
            tag.querySelector('.btn-delete').style.display = 'none';
            tag.querySelector('.btn-save').style.display = 'inline-block';
            tag.querySelector('.btn-cancel').style.display = 'inline-block';
            tag.querySelector('.player-name-edit').focus();
            tag.querySelector('.player-name-edit').select();
        }
        
        function savePlayerName(oldName) {
            const tagId = 'tag-' + oldName.replace(/[^a-zA-Z0-9]/g, '_');
            const tag = document.getElementById(tagId);
            if (!tag) return;
            
            const newName = tag.querySelector('.player-name-edit').value.trim();
            
            if (!newName) {
                alert('Il nome non pu√≤ essere vuoto');
                return;
            }
            
            if (newName !== oldName && savedPlayerNames.includes(newName)) {
                alert('Questo nome esiste gi√†');
                return;
            }
            
            // Update the name in the array
            const index = savedPlayerNames.indexOf(oldName);
            if (index !== -1) {
                savedPlayerNames[index] = newName;
                savedPlayerNames.sort();
                savePlayerNamesToFirebase();
                updatePlayerNameList();
            }
        }
        
        function cancelEditPlayerName(name) {
            updatePlayerNameList();
        }
        
        function addPlayerName() {
            const input = document.getElementById('newPlayerName');
            const name = input.value.trim();
            
            if (!name) {
                alert('Inserisci un nome');
                return;
            }
            
            if (savedPlayerNames.includes(name)) {
                alert('Questo giocatore esiste gi√†');
                return;
            }
            
            savedPlayerNames.push(name);
            savedPlayerNames.sort();
            savePlayerNamesToFirebase();
            updatePlayerNameList();
            input.value = '';
            input.focus();
        }
        
        function removePlayerName(name) {
            if (!confirm(`Rimuovere ${name} dal database?`)) return;
            
            savedPlayerNames = savedPlayerNames.filter(n => n !== name);
            savePlayerNamesToFirebase();
            updatePlayerNameList();
        }

        // Setup button listeners on DOM ready (iOS compatible)
        document.addEventListener('DOMContentLoaded', function() {
            // Add Player button
            document.getElementById('addPlayerBtn').addEventListener('click', function(e) {
                e.preventDefault();
                addPlayerInput();
            });

            // Save Game button
            document.getElementById('saveGameBtn').addEventListener('click', function(e) {
                e.preventDefault();
                saveGame();
            });
            
            // Add Player Name button
            const addPlayerNameBtn = document.getElementById('addPlayerNameBtn');
            if (addPlayerNameBtn) {
                addPlayerNameBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    addPlayerName();
                });
            }
            
            // Enter key on new player name input
            const newPlayerNameInput = document.getElementById('newPlayerName');
            if (newPlayerNameInput) {
                newPlayerNameInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addPlayerName();
                    }
                });
            }
        });

        // Initialize on load
        window.addEventListener('load', initApp);
    </script>
</body>
</html>
